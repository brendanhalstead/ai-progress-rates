# Adding New Parameters to the AI Progress Model

This guide covers the complete process for adding new parameters to the model, following established patterns and best practices.

## Overview

When adding new parameters, you must update 4 main files in sequence:
1. [model_config.py](mdc:model_config.py) - Parameter definitions and bounds
2. [progress_model.py](mdc:progress_model.py) - Parameter class and computation logic
3. [app.py](mdc:app.py) - Web API parameter handling
4. [templates/index.html](mdc:templates/index.html) - User interface controls

## Step 1: Model Configuration ([model_config.py](mdc:model_config.py))

### For Numeric Parameters
```python
# Add bounds to PARAMETER_BOUNDS
PARAMETER_BOUNDS = {
    # ... existing bounds ...
    'your_new_parameter': (min_value, max_value)
}

# Add default to DEFAULT_PARAMETERS
DEFAULT_PARAMETERS = {
    # ... existing defaults ...
    'your_new_parameter': default_value,
}

# CRITICAL: Define clipping constants to prevent hardcoding
# If your parameter needs clipping in computation functions, define explicit constants:
YOUR_PARAMETER_MIN = 0.0  # Or appropriate minimum
YOUR_PARAMETER_MAX = 5.0  # Should match the upper bound in PARAMETER_BOUNDS
```

### For Categorical Parameters
```python
# Define allowed values as constants
YOUR_PARAMETER_OPTIONS = ["option1", "option2", "option3"]
DEFAULT_YOUR_PARAMETER = "option1"

# Add to DEFAULT_PARAMETERS
DEFAULT_PARAMETERS = {
    # ... existing defaults ...
    'your_categorical_parameter': DEFAULT_YOUR_PARAMETER,
}
```

## Step 2: Progress Model ([progress_model.py](mdc:progress_model.py))

### Add to Parameters Class
```python
@dataclass
class Parameters:
    # ... existing parameters ...
    your_new_parameter: float = field(default_factory=lambda: cfg.DEFAULT_PARAMETERS['your_new_parameter'])
    your_categorical_parameter: str = field(default_factory=lambda: cfg.DEFAULT_PARAMETERS['your_categorical_parameter'])
```

### Parameter Validation (Optional)
Add validation in `Parameters.__post_init__()` if needed:
```python
def __post_init__(self):
    # ... existing validation ...
    
    # For numeric parameters with special constraints
    if not np.isfinite(self.your_new_parameter):
        logger.warning(f"Non-finite your_new_parameter: {self.your_new_parameter}, setting to default")
        self.your_new_parameter = cfg.DEFAULT_PARAMETERS['your_new_parameter']
    else:
        # CRITICAL: Use config constants, never hardcode clipping values
        self.your_new_parameter = np.clip(self.your_new_parameter, cfg.YOUR_PARAMETER_MIN, cfg.YOUR_PARAMETER_MAX)
    
    # For categorical parameters
    if self.your_categorical_parameter not in cfg.YOUR_PARAMETER_OPTIONS:
        logger.warning(f"Invalid your_categorical_parameter: {self.your_categorical_parameter}, setting to default")
        self.your_categorical_parameter = cfg.DEFAULT_YOUR_PARAMETER
```

### Use in Computation Functions
Reference the parameter in your computation functions:
```python
def your_computation_function(some_input: float, params: Parameters) -> float:
    # Use params.your_new_parameter in calculations
    if params.your_categorical_parameter == "option1":
        result = some_input * params.your_new_parameter
    else:
        result = some_input / params.your_new_parameter
    
    # CRITICAL: Always use config constants for clipping, never hardcode values
    return np.clip(result, cfg.YOUR_PARAMETER_MIN, cfg.YOUR_PARAMETER_MAX)
    
    # WRONG: return np.clip(result, 0.0, 1.0)  # Never hardcode like this!
    # WRONG: return min(1.0, max(0.0, result))  # Never hardcode like this!
```

## Step 3: Web API ([app.py](mdc:app.py))

### Add Parameter Configuration
Update the `get_parameter_config()` function:
```python
parameter_config = {
    'bounds': cfg.PARAMETER_BOUNDS,
    'defaults': cfg.DEFAULT_PARAMETERS,
    'validation_thresholds': cfg.PARAM_VALIDATION_THRESHOLDS,
    # For categorical parameters, add the options
    'your_parameter_options': cfg.YOUR_PARAMETER_OPTIONS,
    'descriptions': {
        # ... existing descriptions ...
        'your_new_parameter': {
            'name': 'Display Name',
            'description': 'Human-readable description of what this parameter does',
            'units': 'dimensionless' # or appropriate units
        },
        'your_categorical_parameter': {
            'name': 'Category Display Name',
            'description': 'Description of the categorical choice',
            'units': 'categorical'
        }
    }
}
```

### Update Parameter Serialization Functions
Update `params_to_dict()`:
```python
def params_to_dict(params: Parameters):
    return {
        # ... existing parameters ...
        'your_new_parameter': params.your_new_parameter,
        'your_categorical_parameter': params.your_categorical_parameter
    }
```

Update `get_default_data()` route:
```python
'parameters': {
    # ... existing parameters ...
    'your_new_parameter': params.your_new_parameter,
    'your_categorical_parameter': params.your_categorical_parameter
}
```

## Step 4: User Interface ([templates/index.html](mdc:templates/index.html))

### Add UI Controls

#### For Numeric Parameters (Sliders)
```html
<div class="mb-3">
    <label class="param-label">Display Name: <span id="your_new_parameter_val">Loading...</span></label>
    <input type="range" class="range-input form-range" id="your_new_parameter" step="0.1">
    <small class="text-muted">Helpful description with units</small>
</div>
```

#### For Categorical Parameters (Dropdowns)
```html
<div class="mb-3">
    <label class="param-label">Category Name:</label>
    <select class="form-select form-select-sm" id="your_categorical_parameter">
        <option value="option1">Option 1</option>
        <option value="option2">Option 2</option>
    </select>
    <small class="text-muted">Description of the options</small>
</div>
```

### Update JavaScript Parameter Collection
Add to the `parameterIds` array in `collectParameters()`:
```javascript
const parameterIds = [
    // ... existing IDs ...
    'your_new_parameter',
    'your_categorical_parameter'
];
```

### Update Parameter Processing Logic
In `collectParameters()`, add special handling if needed:
```javascript
parameterIds.forEach(id => {
    const element = $('#' + id);
    if (element.length) {
        let value;
        
        // Special handling for categorical parameters
        if (id === 'your_categorical_parameter') {
            value = element.val(); // Keep as string
        } else {
            value = parseFloat(element.val());
            // Add any special numeric transformations here
        }
        
        // Validation for categorical parameters
        if (id === 'your_categorical_parameter') {
            const allowedOptions = parameterConfig?.your_parameter_options || ['option1', 'option2'];
            if (!allowedOptions.includes(value)) {
                console.warn(`Invalid ${id}: ${value}, using default`);
                value = parameterConfig?.defaults?.[id] || 'option1';
            }
        }
        
        params[id] = value;
    }
});
```

### Update Parameter Initialization
In `initializeParameterControls()`:

#### For Dropdowns
```javascript
// Initialize dropdown controls
if (parameterConfig.your_parameter_options && parameterConfig.defaults) {
    const selectElement = document.getElementById('your_categorical_parameter');
    if (selectElement) {
        // Clear existing options
        selectElement.innerHTML = '';
        
        // Add options from config
        parameterConfig.your_parameter_options.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option;
            optionElement.textContent = option.charAt(0).toUpperCase() + option.slice(1);
            selectElement.appendChild(optionElement);
        });
        
        // Set default value
        const defaultValue = parameterConfig.defaults.your_categorical_parameter || 'option1';
        selectElement.value = defaultValue;
    }
}
```

#### For Special Slider Handling
```javascript
// In the slider initialization loop, add special cases:
if (paramName === 'your_special_parameter') {
    // Example: log scale conversion
    slider.min = Math.log10(Math.max(min, 1e-5));
    slider.max = Math.log10(max);
    slider.value = Math.log10(Math.max(defaultValue, 1e-5));
} else {
    slider.min = min;
    slider.max = max;
    slider.value = defaultValue;
}
```

## ⚠️ CRITICAL: Anti-Hardcoding Rules

### The Problem
**NEVER** hardcode parameter limits or clipping values in computation functions. This creates maintenance nightmares and inconsistent behavior across the codebase.

### ❌ WRONG - Examples of what NOT to do:
```python
# DON'T hardcode clipping values
return np.clip(ai_research_taste, 0.0, 1.0)

# DON'T hardcode min/max in conditionals  
ai_research_taste = min(1.0, taste_at_sc * multiplier)

# DON'T hardcode validation bounds
if ai_research_taste > 1.0:
    ai_research_taste = 1.0

# DON'T hardcode fallback limits
taste_at_sc_clamped = max(1e-10, min(taste_at_sc, 1.0))
```

### ✅ CORRECT - Use config constants:
```python
# DO use config constants for clipping
return np.clip(ai_research_taste, cfg.AI_RESEARCH_TASTE_MIN, cfg.AI_RESEARCH_TASTE_MAX)

# DO use config constants in conditionals
ai_research_taste = min(cfg.AI_RESEARCH_TASTE_MAX, taste_at_sc * multiplier)

# DO use config constants for validation
if ai_research_taste > cfg.AI_RESEARCH_TASTE_MAX:
    ai_research_taste = cfg.AI_RESEARCH_TASTE_MAX

# DO use config constants for clamping
taste_at_sc_clamped = max(1e-10, min(taste_at_sc, cfg.AI_RESEARCH_TASTE_MAX))
```

### Clipping Constants Pattern
When adding a parameter that needs clipping in computation functions:

1. **Define constants in model_config.py:**
```python
# Parameter bounds for optimization  
PARAMETER_BOUNDS = {
    'your_parameter': (0.1, 5.0),  # Define the valid range
}

# Clipping constants for computation functions
YOUR_PARAMETER_MIN = 0.0   # Can be different from optimization bounds
YOUR_PARAMETER_MAX = 5.0   # Should match upper bound from PARAMETER_BOUNDS
```

2. **Use consistently across all functions:**
```python
# In Parameters.__post_init__()
self.your_parameter = np.clip(self.your_parameter, cfg.YOUR_PARAMETER_MIN, cfg.YOUR_PARAMETER_MAX)

# In computation functions
return np.clip(result, cfg.YOUR_PARAMETER_MIN, cfg.YOUR_PARAMETER_MAX)

# In conditional logic
value = min(cfg.YOUR_PARAMETER_MAX, computed_value)
```

3. **Update all related functions together** to ensure consistency.

## Best Practices

### Parameter Naming
- Use descriptive, lowercase names with underscores
- Group related parameters with common prefixes
- Example: `ai_research_taste_slope`, `ai_research_taste_at_superhuman_coder`

### Configuration Management
- **Always define constants in [model_config.py](mdc:model_config.py) as the single source of truth**
- **Never hardcode numerical limits in computation functions**
- Use `DEFAULT_PARAMETERS` for all default values
- Define bounds for all numeric parameters in `PARAMETER_BOUNDS`
- Define separate clipping constants (`PARAM_MIN`, `PARAM_MAX`) if computation functions need different limits than optimization bounds

### Error Handling
- Add validation in `Parameters.__post_init__()` for critical constraints
- Use fallback values from config when UI elements fail to parse
- Log warnings for invalid parameter values
- Always use config constants in validation logic

### UI Organization
- Group related parameters in `<div class="param-group">` sections
- Use clear, descriptive labels with units
- Add helpful descriptions in `<small class="text-muted">` elements
- Use consistent styling (Bootstrap classes)

### JavaScript Patterns
- Handle string vs numeric parameters explicitly
- Validate against config-defined allowed values
- Use proper fallbacks for missing or invalid values
- Initialize UI controls from server configuration, not hardcoded values

## Testing Checklist

After adding new parameters:

1. ✅ Python files compile without syntax errors: `python -m py_compile model_config.py progress_model.py app.py`
2. ✅ Parameter appears in UI with correct bounds and default value
3. ✅ Dropdown options (if applicable) load from server config
4. ✅ Parameter validation works for invalid values
5. ✅ Model computation uses the new parameter correctly
6. ✅ Parameter estimation includes the new parameter
7. ✅ Export functions include the new parameter in output
8. ✅ **No hardcoded limits** - Search codebase for hardcoded numerical values related to your parameter
9. ✅ **Consistent clipping** - All computation functions use the same config constants for clipping

## Code Review Checklist

When reviewing parameter additions, check for:

- [ ] All bounds defined in `PARAMETER_BOUNDS`
- [ ] All defaults defined in `DEFAULT_PARAMETERS`  
- [ ] Clipping constants defined for any parameter used in computation functions
- [ ] **No hardcoded numerical limits anywhere in the codebase**
- [ ] Consistent use of config constants across all functions
- [ ] UI controls pull bounds from server config, not hardcoded values

## Example: Recent Implementation

See the `taste_schedule_type` and `progress_at_aa` parameters added in recent commits as a complete reference implementation following these patterns.

**AI Research Taste Fix Example:** The AI research taste parameter was being incorrectly hardcoded to clip at 1.0 in multiple functions. The fix involved:
1. Adding `AI_RESEARCH_TASTE_MIN = 0.0` and `AI_RESEARCH_TASTE_MAX = 5.0` to model_config.py
2. Replacing all instances of `np.clip(value, 0.0, 1.0)` with `np.clip(value, cfg.AI_RESEARCH_TASTE_MIN, cfg.AI_RESEARCH_TASTE_MAX)`
3. Replacing hardcoded `min(1.0, value)` with `min(cfg.AI_RESEARCH_TASTE_MAX, value)`
4. Ensuring consistency across all computation functions