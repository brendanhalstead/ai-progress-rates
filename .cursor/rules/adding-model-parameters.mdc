---
description: Guidelines for adding new parameters to the AI progress model
---

# Adding New Parameters to the AI Progress Model

This guide covers the complete process for adding new parameters to the model, following established patterns and best practices.

## Overview

When adding new parameters, you must update 4 main files in sequence:
1. [model_config.py](mdc:model_config.py) - Parameter definitions and bounds
2. [progress_model.py](mdc:progress_model.py) - Parameter class and computation logic
3. [app.py](mdc:app.py) - Web API parameter handling
4. [templates/index.html](mdc:templates/index.html) - User interface controls

## Step 1: Model Configuration ([model_config.py](mdc:model_config.py))

### For Numeric Parameters
```python
# Add bounds to PARAMETER_BOUNDS
PARAMETER_BOUNDS = {
    # ... existing bounds ...
    'your_new_parameter': (min_value, max_value)
}

# Add default to DEFAULT_PARAMETERS
DEFAULT_PARAMETERS = {
    # ... existing defaults ...
    'your_new_parameter': default_value,
}
```

### For Categorical Parameters
```python
# Define allowed values as constants
YOUR_PARAMETER_OPTIONS = ["option1", "option2", "option3"]
DEFAULT_YOUR_PARAMETER = "option1"

# Add to DEFAULT_PARAMETERS
DEFAULT_PARAMETERS = {
    # ... existing defaults ...
    'your_categorical_parameter': DEFAULT_YOUR_PARAMETER,
}
```

## Step 2: Progress Model ([progress_model.py](mdc:progress_model.py))

### Add to Parameters Class
```python
@dataclass
class Parameters:
    # ... existing parameters ...
    your_new_parameter: float = field(default_factory=lambda: cfg.DEFAULT_PARAMETERS['your_new_parameter'])
    your_categorical_parameter: str = field(default_factory=lambda: cfg.DEFAULT_PARAMETERS['your_categorical_parameter'])
```

### Parameter Validation (Optional)
Add validation in `Parameters.__post_init__()` if needed:
```python
def __post_init__(self):
    # ... existing validation ...
    
    # For numeric parameters with special constraints
    if not np.isfinite(self.your_new_parameter):
        logger.warning(f"Non-finite your_new_parameter: {self.your_new_parameter}, setting to default")
        self.your_new_parameter = cfg.DEFAULT_PARAMETERS['your_new_parameter']
    
    # For categorical parameters
    if self.your_categorical_parameter not in cfg.YOUR_PARAMETER_OPTIONS:
        logger.warning(f"Invalid your_categorical_parameter: {self.your_categorical_parameter}, setting to default")
        self.your_categorical_parameter = cfg.DEFAULT_YOUR_PARAMETER
```

### Use in Computation Functions
Reference the parameter in your computation functions:
```python
def your_computation_function(some_input: float, params: Parameters) -> float:
    # Use params.your_new_parameter in calculations
    if params.your_categorical_parameter == "option1":
        return some_input * params.your_new_parameter
    else:
        return some_input / params.your_new_parameter
```

## Step 3: Web API ([app.py](mdc:app.py))

### Add Parameter Configuration
Update the `get_parameter_config()` function:
```python
parameter_config = {
    'bounds': cfg.PARAMETER_BOUNDS,
    'defaults': cfg.DEFAULT_PARAMETERS,
    'validation_thresholds': cfg.PARAM_VALIDATION_THRESHOLDS,
    # For categorical parameters, add the options
    'your_parameter_options': cfg.YOUR_PARAMETER_OPTIONS,
    'descriptions': {
        # ... existing descriptions ...
        'your_new_parameter': {
            'name': 'Display Name',
            'description': 'Human-readable description of what this parameter does',
            'units': 'dimensionless' # or appropriate units
        },
        'your_categorical_parameter': {
            'name': 'Category Display Name',
            'description': 'Description of the categorical choice',
            'units': 'categorical'
        }
    }
}
```

### Update Parameter Serialization Functions
Update `params_to_dict()`:
```python
def params_to_dict(params: Parameters):
    return {
        # ... existing parameters ...
        'your_new_parameter': params.your_new_parameter,
        'your_categorical_parameter': params.your_categorical_parameter
    }
```

Update `get_default_data()` route:
```python
'parameters': {
    # ... existing parameters ...
    'your_new_parameter': params.your_new_parameter,
    'your_categorical_parameter': params.your_categorical_parameter
}
```

## Step 4: User Interface ([templates/index.html](mdc:templates/index.html))

### Add UI Controls

#### For Numeric Parameters (Sliders)
```html
<div class="mb-3">
    <label class="param-label">Display Name: <span id="your_new_parameter_val">Loading...</span></label>
    <input type="range" class="range-input form-range" id="your_new_parameter" step="0.1">
    <small class="text-muted">Helpful description with units</small>
</div>
```

#### For Categorical Parameters (Dropdowns)
```html
<div class="mb-3">
    <label class="param-label">Category Name:</label>
    <select class="form-select form-select-sm" id="your_categorical_parameter">
        <option value="option1">Option 1</option>
        <option value="option2">Option 2</option>
    </select>
    <small class="text-muted">Description of the options</small>
</div>
```

### Update JavaScript Parameter Collection
Add to the `parameterIds` array in `collectParameters()`:
```javascript
const parameterIds = [
    // ... existing IDs ...
    'your_new_parameter',
    'your_categorical_parameter'
];
```

### Update Parameter Processing Logic
In `collectParameters()`, add special handling if needed:
```javascript
parameterIds.forEach(id => {
    const element = $('#' + id);
    if (element.length) {
        let value;
        
        // Special handling for categorical parameters
        if (id === 'your_categorical_parameter') {
            value = element.val(); // Keep as string
        } else {
            value = parseFloat(element.val());
            // Add any special numeric transformations here
        }
        
        // Validation for categorical parameters
        if (id === 'your_categorical_parameter') {
            const allowedOptions = parameterConfig?.your_parameter_options || ['option1', 'option2'];
            if (!allowedOptions.includes(value)) {
                console.warn(`Invalid ${id}: ${value}, using default`);
                value = parameterConfig?.defaults?.[id] || 'option1';
            }
        }
        
        params[id] = value;
    }
});
```

### Update Parameter Initialization
In `initializeParameterControls()`:

#### For Dropdowns
```javascript
// Initialize dropdown controls
if (parameterConfig.your_parameter_options && parameterConfig.defaults) {
    const selectElement = document.getElementById('your_categorical_parameter');
    if (selectElement) {
        // Clear existing options
        selectElement.innerHTML = '';
        
        // Add options from config
        parameterConfig.your_parameter_options.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option;
            optionElement.textContent = option.charAt(0).toUpperCase() + option.slice(1);
            selectElement.appendChild(optionElement);
        });
        
        // Set default value
        const defaultValue = parameterConfig.defaults.your_categorical_parameter || 'option1';
        selectElement.value = defaultValue;
    }
}
```

#### For Special Slider Handling
```javascript
// In the slider initialization loop, add special cases:
if (paramName === 'your_special_parameter') {
    // Example: log scale conversion
    slider.min = Math.log10(Math.max(min, 1e-5));
    slider.max = Math.log10(max);
    slider.value = Math.log10(Math.max(defaultValue, 1e-5));
} else {
    slider.min = min;
    slider.max = max;
    slider.value = defaultValue;
}
```

## Best Practices

### Parameter Naming
- Use descriptive, lowercase names with underscores
- Group related parameters with common prefixes
- Example: `ai_research_taste_slope`, `ai_research_taste_at_superhuman_coder`

### Configuration Management
- Always define constants in [model_config.py](mdc:model_config.py) as the single source of truth
- Use `DEFAULT_PARAMETERS` for all default values
- Define bounds for all numeric parameters in `PARAMETER_BOUNDS`

### Error Handling
- Add validation in `Parameters.__post_init__()` for critical constraints
- Use fallback values from config when UI elements fail to parse
- Log warnings for invalid parameter values

### UI Organization
- Group related parameters in `<div class="param-group">` sections
- Use clear, descriptive labels with units
- Add helpful descriptions in `<small class="text-muted">` elements
- Use consistent styling (Bootstrap classes)

### JavaScript Patterns
- Handle string vs numeric parameters explicitly
- Validate against config-defined allowed values
- Use proper fallbacks for missing or invalid values
- Initialize UI controls from server configuration, not hardcoded values

## Testing Checklist

After adding new parameters:

1. ✅ Python files compile without syntax errors: `python -m py_compile model_config.py progress_model.py app.py`
2. ✅ Parameter appears in UI with correct bounds and default value
3. ✅ Dropdown options (if applicable) load from server config
4. ✅ Parameter validation works for invalid values
5. ✅ Model computation uses the new parameter correctly
6. ✅ Parameter estimation includes the new parameter
7. ✅ Export functions include the new parameter in output

## Example: Recent Implementation

See the `taste_schedule_type` and `progress_at_aa` parameters added in recent commits as a complete reference implementation following these patterns.